#!/usr/bin/python

import argparse
import string
import os
import subprocess
import plistlib
import tempfile
import shutil


quickpkg_version = '0.2'
supported_extensions = ['dmg', 'app', 'zip']

# quickpkg

# modeled after munkiimport but to build a pkg


def logger(log, v=0):
    if args.verbosity >= v:
        print log


def cmdexec(command, stdin=''):
    """Execute a command."""
    # if 'command' is a string, split the string into components
    if isinstance(command, str):
        command = command.split()

    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
    (stdout, stderr) = proc.communicate(stdin)

    logger("cmdexec: %s, result: %s, error: %s" % (command, stdout, stderr), 3)

    # strip trailing whitespace, which would mess with string comparisons
    return {"return_code": proc.returncode, "stderr": stderr.rstrip(), "stdout": stdout.rstrip()}


# from munkicommons.py
def getFirstPlist(textString):
    """Gets the next plist from a text string that may contain one or
    more text-style plists.
    Returns a tuple - the first plist (if any) and the remaining
    string after the plist"""
    plist_header = '<?xml version'
    plist_footer = '</plist>'
    plist_start_index = textString.find(plist_header)
    if plist_start_index == -1:
        # not found
        return ("", textString)
    plist_end_index = textString.find(
        plist_footer, plist_start_index + len(plist_header))
    if plist_end_index == -1:
        # not found
        return ("", textString)
    # adjust end value
    plist_end_index = plist_end_index + len(plist_footer)
    return (textString[plist_start_index:plist_end_index],
            textString[plist_end_index:])


def dmg_has_sla(dmgpath):
    has_sla = False
    imageinfo_cmd = ['/usr/bin/hdiutil', 'imageinfo', dmgpath, '-plist']
    result = cmdexec(imageinfo_cmd)
    if result["return_code"] != 0:
        print "error getting imageinfo! %s, %s" % (result["return_code"], result["stderr"])
        return False
    result_plist = result["stdout"]
    imageinfo_dict = plistlib.readPlistFromString(result_plist)
    properties = imageinfo_dict.get('Properties')
    if properties is not None:
        has_sla = properties.get('Software License Agreement', False)
    return has_sla


def attachdmg(dmgpath):
    global dmg_was_mounted
    info_cmd = ["hdiutil", "info", "-plist"]
    info_result = cmdexec(info_cmd)
    if info_result["return_code"] == 0:
        # parse the plist output
        (theplist, alltext) = getFirstPlist(info_result["stdout"])
        info_dict = plistlib.readPlistFromString(theplist)
        volpaths = []
        if "images" in info_dict.keys():
            for y in info_dict["images"]:
                if "image-path" in y.keys():
                    if os.path.samefile(y["image-path"], dmgpath):
                        for x in y.get("system-entities"):
                            if "mount-point" in x.keys():
                                volpaths.append(x["mount-point"])
                                dmg_was_mounted = True
                        return volpaths
    else:
        print "error getting hdiutil info"
        print "(%d, %s)" % (info_result["returncode"], info_result["stderr"])
        cleanup_and_exit(1)

    attachcmd = ["/usr/bin/hdiutil",
                 "attach",
                 dmgpath,
                 "-mountrandom",
                 "/private/tmp",
                 "-plist",
                 "-nobrowse"]
    if dmg_has_sla(dmgpath):
        stdin = "Y\n"
        print "NOTE: Disk image %s has a license agreement!" % dmgpath
    else:
        stdin = ''
    result = cmdexec(attachcmd, stdin)
    if result["return_code"] == 0:
        # parse the plist output
        (theplist, alltext) = getFirstPlist(result["stdout"])
        resultdict = plistlib.readPlistFromString(theplist)
        volpaths = []
        for x in resultdict["system-entities"]:
            if x["potentially-mountable"]:
                if x["volume-kind"] == 'hfs':
                    volpaths.append(x["mount-point"])
        # return the paths to mounted volume
        return volpaths
    else:
        print "error mounting disk image"
        print "(%d, %s)" % (result["returncode"], result["stderr"])
        cleanup_and_exit(1)


def detachpaths(volpaths):
    for x in volpaths:
        if os.path.exists(x):
            if os.path.ismount(x):
                detachcmd = ["/usr/bin/hdiutil", "detach", x]
                cmdexec(detachcmd)


def finditemswithextension(dirpath, item_extension):
    foundapps = []
    if os.path.exists(dirpath):
        for x in os.listdir(dirpath):
            (item_basename, item_extension) = os.path.splitext(x)
            item_extension = string.lstrip(item_extension, '.')
            if item_extension == 'app':
                foundapps.append(os.path.join(dirpath, x))
    else:
        print "path %s does not exist" % dirpath
        cleanup_and_exit(1)
    return foundapps


def appNameAndVersion(app_path):
    info_path = os.path.join(app_path, "Contents/Info.plist")
    if not os.path.exists(info_path):
        print "Application at path %s does not have Info.plist" % app_path
        # TODO: cleanup volumes here
        cleanup_and_exit(1)
    info_plist = plistlib.readPlist(info_path)
    app_name = info_plist.get("CFBundleName", None)
    if app_name is None:
        app_name = info_plist.get("CFBundleExecutable", None)
    app_identifier = info_plist.get("CFBundleIdentifier", None)
    app_version = info_plist.get("CFBundleShortVersionString", None)
    if app_version is None:
        app_version = info_plist.get("CFBundleVersion", None)
    return (app_name, app_identifier, app_version)


def cleanup_and_exit(returncode):
    global dmgvolumepaths
    global dmg_was_mounted
    global tmp_path

    if not dmg_was_mounted:
        detachpaths(dmgvolumepaths)
    if tmp_path is not None:
        shutil.rmtree(tmp_path)
    exit(returncode)


if __name__ == "__main__":

    # for convenience link to argparse tutorial:
    # https://docs.python.org/2/howto/argparse.html#id1
    parser = argparse.ArgumentParser(description="Attempts to build a pkg from the input.",
                                     epilog="""Installer item can be a dmg, zip, or app.

        Example:
        quickpkg /path/to/installer_item""", formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('--version', help='prints the version', action='version', version=quickpkg_version)

    # takes a path as input
    parser.add_argument('item_path', help="path to the installer item")

    parser.add_argument("-v", "--verbosity", action="count", default=0, help="controls amount of logging output (max -vvv)")

    args = parser.parse_args()

    # remove trailing '/' from path
    item_path = string.rstrip(args.item_path, '/')

    if item_path.startswith('~'):
        item_path = os.path.expanduser(item_path)
    item_path = os.path.abspath(item_path)

    # get file extension
    (item_basename, item_extension) = os.path.splitext(item_path)
    item_extension = string.lstrip(item_extension, '.')

    # is extension supported
    if item_extension not in supported_extensions:
        print ".%s is not a supported extension!" % item_extension
        exit(1)

    # if item is an app, just pass it on
    if item_extension == 'app':
        if not os.path.exists(item_path):
            print "This does not seem to be an Application!"
            exit(1)

        app_path = item_path

    dmgvolumepaths = []
    tmp_path = None
    dmg_was_mounted = False

    # if item is a dmg, mount it and find useful contents
    if item_extension == 'dmg':
        dmgvolumepaths = attachdmg(item_path)
        foundapps = []
        for x in dmgvolumepaths:
            moreapps = finditemswithextension(x, 'app')
            foundapps.extend(moreapps)
        if len(foundapps) == 0:
            print "Could not find an application!"
            cleanup_and_exit(1)
        elif len(foundapps) > 1:
            print "Found too many Applications! Can't decide!"
            print foundapps
            cleanup_and_exit(1)

        app_path = foundapps[0]

    # if item is zip, unzip to tmp location and find useful contents
    if item_extension == 'zip':
        tmp_path = tempfile.mkdtemp()
        unzip_cmd = ["/usr/bin/unzip", "-d", tmp_path, item_path]
        result = cmdexec(unzip_cmd)
        if result["return_code"] != 0:
            print "An error occured while unzipping:"
            print "%d, %s" % (result["return_code"], result["stderr"])
            cleanup_and_exit(1)
        foundapps = finditemswithextension(tmp_path, 'app')
        if len(foundapps) == 0:
            print "Could not find an application!"
            cleanup_and_exit(1)
        elif len(foundapps) > 1:
            print "Found too many Applications! Can't decide!"
            print foundapps
            cleanup_and_exit(1)

        app_path = foundapps[0]

    logger("Found application: %s" % app_path, 1)

    # extract version and other metadata
    (app_name, app_identifier, app_version) = appNameAndVersion(app_path)

    logger("Name: %s, ID: %s, Version: %s" % (app_name, app_identifier, app_version), 1)

    # TODO: get name syntax from prefs or parameter
    pkg_name = "{name}-{version}.pkg".format(name=app_name, version=app_version, identifier=app_identifier)
    pkg_name = pkg_name.replace(' ', '')  # remove spaces
    # run pkgutil to build result

    pkgcmd = ["/usr/bin/pkgbuild",
              "--component", app_path,
              "--identifier", app_identifier,
              "--version", app_version,
              "--install-location", "/Applications",
              pkg_name]
    result = cmdexec(pkgcmd)

    logger(result["stdout"], 1)
    if result["return_code"] != 0:
        print "Error Code: " + result["return_code"]
        print result["stderr"]
    else:
        print pkg_name

    cleanup_and_exit(0)
